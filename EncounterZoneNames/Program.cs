using Mutagen.Bethesda;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Strings;

namespace EncounterZoneNames
{
    public class Program
    {
        private static Lazy<Settings> _formSettings = null!;
        
        public static async Task<int> Main(string[] args)
        {
            // Initialize and run the Synthesis patcher pipeline
            return await SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch) // Add the patching function
                .SetAutogeneratedSettings(
                    "Settings",
                    "Settings.json",
                    out _formSettings)
                .SetTypicalOpen(GameRelease.SkyrimSE, "EncounterZoneNames.esp")
                .Run(args); // Execute the pipeline with provided arguments
        }

        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            var patchCellNames = _formSettings.Value.PatchCellNames;
            var patchMapMarkers = _formSettings.Value.PatchMapMarkers;
            var levelPrefixSingular = _formSettings.Value.LevelPrefixSingular;
            var levelPrefixPlural = _formSettings.Value.LevelPrefixPlural;
            var targetLanguage = _formSettings.Value.TargetLanguage;
            var usePlus = _formSettings.Value.UsePlus;
            var useHyphen = _formSettings.Value.UseHyphen;
            var verbose = _formSettings.Value.Verbose;
            
            string plus = usePlus ? "+" : "";
            string hyphen = useHyphen ? "-" : "to";

            // Do nothing if both patches are disabled
            if (!patchCellNames && !patchMapMarkers)
            {
                Console.WriteLine($"Both patches are disabled... Make sure to enable at least one before running.");
                Environment.Exit(1);
            }
            
            // Dictionary to store location FormKeys and their associated encounter zone levels
            Dictionary<FormKey, List<int>> locationLevels = new Dictionary<FormKey, List<int>>();
            
            // Iterate over all winning override Cell records in the load order
            foreach (var cell in state.LoadOrder.PriorityOrder.Cell().WinningOverrides())
            {
                try
                {
                    // Check if the cell has a name, is an interior, and has an associated EncounterZone
                    if (cell.Name != null &&
                        cell.Flags.HasFlag(Cell.Flag.IsInteriorCell) 
                        && !cell.EncounterZone.IsNull)
                    {
                        // Resolve the EncounterZone record using its FormKey
                        var encounterZone =
                            state.LinkCache.Resolve<IEncounterZoneGetter>(cell.EncounterZone.FormKey);
                        
                        // Ensure both encounterZone and location are successfully resolved and that the encounterZone
                        // has a valid (> 0) minimum level and valid (>= 0) maximum level
                        if (encounterZone is { MinLevel: > 0, MaxLevel: >= 0 })
                        {
                            string levelInfo;
                            if (encounterZone.MinLevel < encounterZone.MaxLevel)
                            {
                                levelInfo = $"{levelPrefixPlural} {encounterZone.MinLevel} {hyphen} " +
                                            $"{encounterZone.MaxLevel}";
                            } 
                            else if (encounterZone.MinLevel == encounterZone.MaxLevel || encounterZone.MaxLevel == 0)
                            {
                                levelInfo = $"{levelPrefixSingular} {encounterZone.MinLevel}{plus}";
                            } 
                            else // if (encounterZone.MaxLevel < encounterZone.MinLevel and encounterZone.MaxLevel != 0)
                            {
                                if (verbose)
                                {
                                    Console.WriteLine($"Skipping cell {cell.FormKey} {cell.Name} since its " +
                                                      $"associated EncounterZone: {cell.EncounterZone.FormKey} has " +
                                                      $"an invalid level range (min level is higher than max level).");
                                }
                                continue;
                            }

                            if (patchCellNames)
                            {
                                // Get original (translated) cell name
                                var originalNameTranslated = new TranslatedString(targetLanguage, cell.Name!.String);
                            
                                // Construct the new  (translated) name with the level range
                                var newName = $"{originalNameTranslated} ({levelInfo})";
                                var newNameTranslated = new TranslatedString(targetLanguage, newName);
                                
                                // Get cell context and use it to retrieve or create override record
                                var cellContext = state.LinkCache.ResolveContext<ICell, ICellGetter>(cell.FormKey);
                                var overrideCell = cellContext.GetOrAddAsOverride(state.PatchMod);
                                
                                // Change name of override record to new name
                                overrideCell.Name = newNameTranslated;
                            
                                Console.WriteLine($"Successfully processed cell {cell.FormKey} from " +
                                                  $"{originalNameTranslated} -> {newNameTranslated}! ");
                            }

                            // Skip map marker stuff if map marker patch is disabled
                            if (!patchMapMarkers) continue;
                            
                            // Process the location; if this cell has an associated location and map marker,
                            // add it to the dict with the cell's min/max levels so we can process the map marker later
                                
                            // Skip if encounter zone has invalid or 0 min AND max levels
                            if (encounterZone is { MinLevel: <= 0, MaxLevel: <= 0 })
                            {
                                if (verbose)
                                {
                                    Console.WriteLine($"Skipping map marker for cell {cell.FormKey} {cell.Name} " +
                                                      $"since its encounter zone has maximum AND minimum levels that " +
                                                      $"are both either 0 or invalid (negative).");
                                }
                                continue;
                            }
                                
                            // Skip if no associated location
                            if (cell.Location.IsNull)
                            {
                                if (verbose)
                                {
                                    Console.WriteLine($"Skipping map marker for cell {cell.FormKey} {cell.Name} " +
                                                      $"since it has no associated location.");
                                }
                                continue;
                            }
                            // Resolve Location record using FormKey
                            var location = state.LinkCache.Resolve<ILocationGetter>(cell.Location.FormKey);
                                
                            // Skip if no associated worldRef
                            if (location.WorldLocationMarkerRef.IsNull) 
                            {
                                if (verbose)
                                {
                                    Console.WriteLine($"Skipping map marker for cell {cell.FormKey} {cell.Name} " +
                                                      $"since its location has no associated world location marker.");
                                }
                                continue;
                            }
                            // Resolve worldRef using FormKey
                            var worldLocationMarker = 
                                state.LinkCache.Resolve<IPlacedObjectGetter>(location.WorldLocationMarkerRef.FormKey);

                            // Skip if no associated map marker
                            if (worldLocationMarker.MapMarker == null) 
                            {
                                if (verbose)
                                {
                                    Console.WriteLine($"Skipping map marker for cell {cell.FormKey} {cell.Name} " +
                                                      $"since its location's world location marker has has no " +
                                                      $"associated map marker.");
                                }
                                continue;
                            }
                                
                            // Add new entry to dict if location hasn't been added already from an earlier cell
                            if (!locationLevels.ContainsKey(location.FormKey))
                            {
                                locationLevels[location.FormKey] = new List<int>();
                            }
                                
                            // If encounterZone has a valid MinLevel, add it to this location's level set
                            if (encounterZone.MinLevel > 0)
                            {
                                locationLevels[location.FormKey].Add(encounterZone.MinLevel);
                            }

                            // If encounterZone has a valid MaxLevel, add it to this location's level set
                            if (encounterZone.MaxLevel > 0)
                            {
                                locationLevels[location.FormKey].Add(encounterZone.MaxLevel);
                            }
                        }
                        else if (encounterZone.MinLevel == 0)
                        {
                            if (verbose) 
                            {
                                Console.WriteLine($"Skipping cell {cell.FormKey} {cell.Name} since its associated " +
                                                  $"EncounterZone: {cell.EncounterZone.FormKey} has no minimum level.");
                            }
                        }
                        else if (encounterZone.MinLevel < 0)
                        {
                            if (verbose) 
                            {
                                Console.WriteLine($"Skipping Cell {cell.FormKey} {cell.Name} since its associated " +
                                                  $"EncounterZone: {cell.EncounterZone.FormKey} has an invalid " +
                                                  $"(negative) minimum level ({encounterZone.MinLevel}).");
                            }
                        }
                    }
                    else if (cell.Name == null)
                    {
                        if (verbose)
                        {
                            Console.WriteLine($"Skipping cell {cell.FormKey} since it has no Name.");
                        }
                        
                    }
                    else if (!cell.Flags.HasFlag(Cell.Flag.IsInteriorCell))
                    {
                        if (verbose)
                        {
                            Console.WriteLine($"Skipping Cell: {cell.FormKey} {cell.Name} since it is not an " +
                                              $"interior.");
                        }
                    }
                    else if (cell.EncounterZone.IsNull)
                    {
                        if (verbose)
                        {
                            Console.WriteLine($"Skipping Cell: {cell.FormKey} {cell.Name} since it has no associated " +
                                              $"EncounterZone.");
                        }
                    }
                    else if (cell.Location.IsNull)
                    {
                        if (verbose)
                        {
                            Console.WriteLine($"Skipping Cell {cell.FormKey} {cell.Name} since it has no associated " +
                                              $"Location.");
                        }
                    }
                }
                catch (Mutagen.Bethesda.Plugins.Exceptions.MissingRecordException e) when
                      (e.Type == typeof(IEncounterZoneGetter))
                {
                    if (verbose)
                    {
                        Console.WriteLine($"Skipping Cell {cell.FormKey} {cell.Name} since its associated " +
                                          $"EncounterZone could not be found and likely does not exist.");
                    }
                }
                catch (Mutagen.Bethesda.Plugins.Exceptions.MissingRecordException e) when
                      (e.Type == typeof(ILocationGetter))
                {
                    if (verbose)
                    {
                        Console.WriteLine($"Skipping Cell {cell.FormKey} {cell.Name} since its associated Location " +
                                          $"could not be found and likely does not exist.");
                    }
                }
                catch (Exception e)
                {
                    // Stop and throw any other exceptions that occur during processing
                    throw new Exception($"Unknown error while processing Cell {cell.FormKey} {cell.Name}: {e.Message}", 
                                        e);
                }
            }

            // Skip map marker patch if it's disabled
            if (!patchMapMarkers) return;
            
            // Process each location to update its map marker's name with the level range
            foreach (var locationLevelPair in locationLevels)
            {
                try
                {
                    // Resolve the Location record using its FormKey (stored in the keys of the dict)
                    var location = state.LinkCache.Resolve<ILocationGetter>(locationLevelPair.Key);
                    
                    // Skip if location has no associated worldRef (it should since it otherwise wouldn't have made
                    // it into the dict, but just in case)
                    if (location.WorldLocationMarkerRef.IsNull)
                    {
                        if (verbose)
                        {
                            Console.WriteLine($"Skipping map marker for location {location.FormKey} " +
                                              $"{location.Name} since it has no associated world location marker.");
                        }
                        continue;
                    }
                    
                    // Get WorldLocationRef so we can pull map marker from it
                    var worldLocationMarker = state.LinkCache.Resolve<IPlacedObjectGetter>
                        (location.WorldLocationMarkerRef.FormKey);
                    // Skip if no associated map marker
                    if (worldLocationMarker.MapMarker == null)
                    {
                        if (verbose)
                        {
                            Console.WriteLine($"Skipping map marker for location {location.FormKey} " +
                                              $"{location.Name} since its associated world location marker " +
                                              $"{worldLocationMarker.FormKey} has no associated map marker.");
                        }
                        continue;
                    }
                    var mapMarker = worldLocationMarker.MapMarker;
                            
                    // Determine the level range (get non-duplicates and sort lowest to highest)
                    var levels = locationLevelPair.Value.OrderBy(level => level).Distinct().ToList();
                    string levelInfo = levels.Count == 1
                        ? $"{levelPrefixSingular} {levels.First()}{plus}"
                        : $"{levelPrefixPlural} {levels.First()} {hyphen} {levels.Last()}";
                    
                    // Get original (translated) map marker name
                    var originalNameTranslated = new TranslatedString(targetLanguage, mapMarker.Name!.String);
                    // Construct the new name with the level range
                    var newName = $"{originalNameTranslated} ({levelInfo})";
                    var newNameTranslated = new TranslatedString(targetLanguage, newName);
                    
                    var worldRefContext = state.LinkCache.ResolveContext<IPlacedObject, IPlacedObjectGetter>
                        (worldLocationMarker.FormKey);
                    var overrideWorldRef = worldRefContext.GetOrAddAsOverride(state.PatchMod);
                    overrideWorldRef.MapMarker!.Name = newName;
                    
                    Console.WriteLine($"Successfully processed map marker for location " +
                                      $"{location.FormKey} {location.Name} from {originalNameTranslated} -> " +
                                      $"{newNameTranslated}! ");
                }
                catch (Exception e)
                {
                    // Stop and throw any exceptions that occur during processing
                    throw new Exception($"Unknown error while processing map marker for location " +
                                        $"{locationLevelPair.Key}: {e.Message}", e);
                }
            }
        }
    }
}
